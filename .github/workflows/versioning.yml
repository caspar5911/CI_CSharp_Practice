name: Auto Version Bump and Tag

on:
  push:
    branches:
      - main

jobs:
  versioning:
    runs-on: ubuntu-latest
    steps:
      # Checkout the current code
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Detect which files changed
      - name: Detect Changed Files
        id: detect_changes
        run: |
          # Get the list of changed files between current and previous commit
          git diff --name-only ${{ github.event.before }} ${{ github.sha }} > changed_modules.txt || true

          # Empty the output file that stores valid module paths
          > modules_with_assemblyinfo.txt

          # Loop through changed files to find closest AssemblyInfo.cs file upwards
          while read -r filepath; do
            dir=$(dirname "$filepath")
            while [ "$dir" != "." ] && [ "$dir" != "/" ]; do
              if [ -f "$dir/Properties/AssemblyInfo.cs" ]; then
                echo "$dir" >> modules_with_assemblyinfo.txt
                break
              fi
              dir=$(dirname "$dir")
            done
          done < changed_modules.txt

          # Deduplicate and sort the list of valid modules
          sort modules_with_assemblyinfo.txt | uniq > valid_modules.txt
          cat changed_modules.txt

      # Detect commit message type (major, minor, patch)
      - name: Detect Version Type
        id: detect_version
        run: |
          # Get commit messages between the current and previous commit
          commits=$(git log --oneline ${{ github.event.before }}..${{ github.sha }})
          echo "HELPPPP"
          echo "$commits"
          # Initialize version bump type
          version_bump="revision"  # Default to patch

          # Check each commit message for breaking change (major), feat (minor), or fix (build)
          echo "$commits" | while read -r commit; do
            echo "CLLLLL"
            echo "$commit"
            if [[ "$commit" == *"BREAKING CHANGE:"* ]]; then
              version_bump="major"
            elif [[ "$commit" == *"feat:"* ]]; then
              version_bump="minor"
            elif [[ "$commit" == *"fix:"* ]]; then
              version_bump="build"
            fi
          done

          # Output the detected version bump type
          echo "Version bump detected: $version_bump"
          echo "::set-output name=version_bump::$version_bump"

      # Update the AssemblyFileVersion (4-digit) based on version bump
      - name: Bump FileVersion in AssemblyInfo.cs
        id: bump
        run: |
          version_bump="${{ steps.detect_version.outputs.version_bump }}"
          
          if [ -s valid_modules.txt ]; then
            > module_versions.txt
            while IFS= read -r module_path; do
              file="$module_path/Properties/AssemblyInfo.cs"
              echo "Updating version in $file"
              if [ -f "$file" ]; then
                # Extract full 4-part version (e.g., 1.2.3.4)
                current_version=$(grep -oP 'AssemblyFileVersion\("\K[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' "$file")
                echo "Current version: $current_version"
          
                IFS='.' read -r major minor build revision <<< "$current_version"
                
                # Determine which part to bump based on the version bump type
                if [ "$version_bump" == "major" ]; then
                  new_version="$((major + 1)).0.0.0"
                elif [ "$version_bump" == "minor" ]; then
                  new_version="$major.$((minor + 1)).0.0"
                elif [ "$version_bump" == "build" ]; then
                  new_version="$major.$minor.$((build + 1)).0"
                else
                  new_version="$major.$minor.$build.$((revision + 1))"
                fi

                # Replace full 4-part version safely
                sed -i "s/AssemblyFileVersion(\"$current_version\"/AssemblyFileVersion(\"$new_version\"/" "$file"
          
                echo "$module_path|$new_version" >> module_versions.txt
                echo "Updated to version: $new_version"
              fi
            done < valid_modules.txt
          else
            echo "No valid modules found."
          fi

      # Commit the updated version files
      - name: Commit version bumps
        run: |
          if [ -f module_versions.txt ]; then
            # Check if there are any changes to commit
            git diff --exit-code || echo "Changes detected"
            
            # If there are changes, commit and push
            if [[ -n $(git status -s) ]]; then
              git config user.name "github-actions"
              git config user.email "github-actions@github.com"
              git add .
              git commit -m "Bump AssemblyFileVersion for updated modules"
              git push
            else
              echo "No changes to commit."
            fi
          else
            echo "No modules updated."
          fi

      # Tag each updated module with its new version
      - name: Tag updated modules
        run: |
          if [ -f module_versions.txt ]; then
            while IFS='|' read -r module version; do
              # Make sure version is quoted and escaped properly
              tag="${module}/v${version}"

              # Check if the tag already exists
              if git rev-parse "$tag" >/dev/null 2>&1; then
                echo "Tag $tag already exists, skipping tag creation."
              else
                echo "Creating tag: $tag"
                # Create and push the tag
                git tag -a "$tag" -m "Bump ${module} to ${version}"
                git push "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/caspar5911/CI_CSharp_Practice" "$tag"
              fi
            done < module_versions.txt
          else
            echo "No versioned modules to tag."
          fi
